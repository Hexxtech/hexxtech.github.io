<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ServerSeed List View (IndexedDB with Full Controls)</title>
  <style>
    body {
      margin: 1rem;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #121212;
      color: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    h2 {
      margin-bottom: 1rem;
    }
    #controls {
      max-width: 480px;
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    #controls > * {
      flex: 1 1 110px;
      min-width: 110px;
    }
    #searchInput {
      flex-grow: 2;
      min-width: 150px;
      padding: 0.5rem;
      font-size: 1rem;
      border-radius: 6px;
      border: 1px solid #444;
      background-color: #222;
      color: #eee;
    }
    button {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background-color: #0078d7;
      color: white;
      user-select: none;
      min-width: 110px;
    }
    button:disabled {
      background-color: #555;
      cursor: default;
    }
    #serverSeedList {
      width: 100%;
      max-width: 480px;
      height: 220px;
      overflow-y: auto;
      background-color: #222;
      border: 1px solid #444;
      padding: 0;
      list-style: none;
      border-radius: 6px;
      margin-bottom: 1rem;
    }
    #serverSeedList li {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #333;
      cursor: pointer;
      user-select: none;
      font-family: monospace;
      font-size: 0.875rem;
    }
    #serverSeedList li:hover {
      background-color: #333;
    }
    #serverSeedList li.selected {
      background-color: #0078d7;
      color: white;
    }
    label {
      font-weight: 600;
      align-self: flex-start;
      margin-left: calc(50% - 240px);
      max-width: 480px;
      margin-bottom: 0.25rem;
    }
    #hashedValue {
      width: 100%;
      max-width: 480px;
      min-height: 4rem;
      font-family: monospace;
      font-size: 1rem;
      padding: 0.75rem 1rem;
      background-color: #222;
      color: #eee;
      border: 1px solid #444;
      border-radius: 6px;
      resize: none;
      overflow-wrap: break-word;
      white-space: pre-wrap;
      margin-bottom: 1rem;
    }
    @media (max-width: 520px) {
      body {
        margin: 0.5rem;
      }
      label {
        margin-left: 0;
      }
      #serverSeedList, #hashedValue, button, #searchInput {
        max-width: 100%;
      }
      #controls {
        gap: 0.25rem;
      }
    }
    #importFileInput {
      display: none;
    }
  </style>
</head>
<body>

  <h2>ServerSeed List View (IndexedDB with Full Controls)</h2>

  <div id="controls">
    <input id="searchInput" type="text" placeholder="Search or add serverSeed, press Enter" aria-label="Search or add serverSeed" />
    <button id="removeSelectedBtn" disabled>Remove Selected</button>
    <button id="exportBtn" title="Export serverSeed data to JSON file">Export</button>
    <button id="importBtn" title="Import serverSeed data from JSON file">Import</button>
    <input id="importFileInput" type="file" accept="application/json" aria-label="Import JSON file" />
    <button id="generateSeedsBtn" title="Generate seeds by prompt">Generate Seeds</button>
    <button id="generate1MSeedsBtn" title="Generate 1,000,000 seeds">Generate 1M Seeds</button>
    <button id="clearDbBtn" title="Clear database">Clear Database</button>
  </div>

  <label for="serverSeedList">Server Seeds:</label>
  <ul id="serverSeedList" role="listbox" tabindex="0" aria-label="Server Seeds"></ul>

  <label for="hashedValue">Matching ServerSeedHashed:</label>
  <textarea id="hashedValue" readonly aria-live="polite" aria-label="ServerSeed Hashed Value"></textarea>

<script>
  const DB_NAME = "serverSeedDb";
  const DB_VERSION = 1;
  const STORE_NAME = "seeds";

  const defaultSeeds = [
    {
      serverSeed: "01707b9930c0bba21babd5147aceac2ee18d3136abdafb099e714e7987f4aafc",
      serverSeedHashed: "407ca67c38df3580b0e1e90ddd414047d93ef33bbb0ba8da0c741d164abf918a"
    },
    {
      serverSeed: "11a560e32e5f50c3f0354602eb16153e70e3233e0fc2461e358dbcd82987e2de",
      serverSeedHashed: "a92037341f61813cb30c573cbf5616db6f42729811a1325a89cf17bec4a5dadc"
    }
  ];

  let db;
  let serverSeedDataArr = [];
  let filteredData = [];
  let selectedIndex = -1;

  const serverSeedList = document.getElementById('serverSeedList');
  const hashedValue = document.getElementById('hashedValue');
  const searchInput = document.getElementById('searchInput');
  const removeSelectedBtn = document.getElementById('removeSelectedBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const importFileInput = document.getElementById('importFileInput');
  const generateSeedsBtn = document.getElementById('generateSeedsBtn');
  const generate1MSeedsBtn = document.getElementById('generate1MSeedsBtn');
  const clearDbBtn = document.getElementById('clearDbBtn');

  async function openDb() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        db = request.result;
        resolve(db);
      };
      request.onupgradeneeded = (e) => {
        db = e.target.result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          const store = db.createObjectStore(STORE_NAME, { keyPath: "serverSeed" });
          store.createIndex("serverSeedHashed", "serverSeedHashed", { unique: false });
        }
      };
    });
  }

  function addSeed(seed) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readwrite");
      const store = tx.objectStore(STORE_NAME);
      const request = store.add(seed);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  function getSeed(serverSeed) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readonly");
      const store = tx.objectStore(STORE_NAME);
      const request = store.get(serverSeed);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  function updateSeed(seed) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readwrite");
      const store = tx.objectStore(STORE_NAME);
      const request = store.put(seed);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  function deleteSeed(serverSeed) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readwrite");
      const store = tx.objectStore(STORE_NAME);
      const request = store.delete(serverSeed);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  function getAllSeeds() {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readonly");
      const store = tx.objectStore(STORE_NAME);
      const request = store.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  function clearAllSeeds() {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readwrite");
      const store = tx.objectStore(STORE_NAME);
      const request = store.clear();
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  const serverSeedList = document.getElementById('serverSeedList');
  const hashedValue = document.getElementById('hashedValue');

  function populateList() {
    serverSeedList.innerHTML = '';
    filteredData.forEach((item, idx) => {
      const li = document.createElement('li');
      li.textContent = item.serverSeed;
      li.setAttribute('role', 'option');
      li.tabIndex = -1;
      li.dataset.index = idx;
      li.addEventListener('click', () => {
        selectItem(idx);
      });
      serverSeedList.appendChild(li);
    });
    if (filteredData.length === 0) {
      selectItem(-1);
    } else if (selectedIndex >= filteredData.length || selectedIndex === -1) {
      selectItem(0);
    } else {
      selectItem(selectedIndex);
    }
  }

  function selectItem(index) {
    if (selectedIndex >= 0 && serverSeedList.children[selectedIndex]) {
      serverSeedList.children[selectedIndex].classList.remove('selected');
    }
    selectedIndex = index;
    if (selectedIndex === -1) {
      hashedValue.value = '';
      removeSelectedBtn.disabled = true;
      return;
    }
    const selectedItem = serverSeedList.children[selectedIndex];
    selectedItem.classList.add('selected');
    selectedItem.focus();
    hashedValue.value = filteredData[selectedIndex].serverSeedHashed;
    removeSelectedBtn.disabled = false;
  }

  serverSeedList.addEventListener('keydown', (e) => {
    if (filteredData.length === 0) return;
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      let nextIndex = selectedIndex + 1;
      if (nextIndex >= filteredData.length) nextIndex = 0;
      selectItem(nextIndex);
      serverSeedList.children[nextIndex].scrollIntoView({ block: 'nearest' });
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      let prevIndex = selectedIndex - 1;
      if (prevIndex < 0) prevIndex = filteredData.length - 1;
      selectItem(prevIndex);
      serverSeedList.children[prevIndex].scrollIntoView({ block: 'nearest' });
    }
  });

  searchInput.addEventListener('keydown', async (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      const val = searchInput.value.trim();
      if (val === '') return;
      // Check if exists already
      const existing = await getSeed(val);
      if (existing) {
        alert('This serverSeed already exists.');
        return;
      }
      try {
        const hashed = await sha256(val);
        await addSeed({ serverSeed: val, serverSeedHashed: hashed });
        searchInput.value = '';
        await reloadData();
        selectItem(filteredData.length - 1);
      } catch (err) {
        alert('Error adding seed: ' + err);
      }
      return;
    }
    setTimeout(() => {
      applyFilter();
    }, 0);
  });

  removeSelectedBtn.addEventListener('click', async () => {
    if (selectedIndex === -1) return;
    const toRemove = filteredData[selectedIndex].serverSeed;
    try {
      await deleteSeed(toRemove);
      await reloadData();
    } catch (e) {
      alert('Error removing seed: ' + e.message);
    }
  });

  exportBtn.addEventListener('click', async () => {
    try {
      const allSeeds = await getAllSeeds();
      if (allSeeds.length === 0) {
        alert('No data to export.');
        return;
      }
      const dataStr = JSON.stringify(allSeeds, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'serverSeedData.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (e) {
      alert('Export failed: ' + e.message);
    }
  });

  importBtn.addEventListener('click', () => {
    importFileInput.value = '';
    importFileInput.click();
  });

  importFileInput.addEventListener('change', async () => {
    const file = importFileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const importedData = JSON.parse(e.target.result);
        if (!Array.isArray(importedData) || !importedData.every(item => 'serverSeed' in item && 'serverSeedHashed' in item)) {
          throw new Error('Invalid JSON structure');
        }
        if (!confirm('This will replace all current data. Continue?')) return;
        await clearAllSeeds();
        for (const item of importedData) {
          await addSeed(item);
        }
        await reloadData();
        if (filteredData.length > 0) selectItem(0);
        alert('Import successful.');
      } catch (ex) {
        alert('Import failed: ' + ex.message);
      }
    };
    reader.readAsText(file);
  });

  generateSeedsBtn.addEventListener('click', async () => {
    const input = prompt('How many serverSeeds to generate? Enter a positive number:');
    if (!input) return;
    const num = parseInt(input, 10);
    if (isNaN(num) || num <= 0) {
      alert('Please enter a valid positive number.');
      return;
    }
    try {
      await batchGenerateSeeds(num);
      await reloadData();
      alert(`${num} serverSeed(s) generated and saved.`);
    } catch (e) {
      alert('Error generating seeds: ' + e.message);
    }
  });

  generate1MSeedsBtn.addEventListener('click', async () => {
    if (!confirm('This will generate and save 1,000,000 unique server seeds. This may be slow and resource intensive. Continue?')) return;
    try {
      await batchGenerateSeeds(1000000);
      await reloadData();
      alert('1,000,000 server seeds generated and saved.');
    } catch (e) {
      alert('Error generating seeds: ' + e.message);
    }
  });

  clearDbBtn.addEventListener('click', async () => {
    if (!confirm('Are you sure you want to delete all saved data? This action cannot be undone.')) return;
    try {
      await clearAllSeeds();
      await reloadData();
      alert('Database cleared.');
    } catch (e) {
      alert('Error clearing database: ' + e.message);
    }
  });

  async function reloadData() {
    serverSeedDataArr = await getAllSeeds();
    applyFilter();
  }

  // Generate cryptographically secure random seed function
  function generateServerSeed(lengthBytes = 32, encoding = 'hex') {
    if (lengthBytes < 16) {
      throw new Error('serverSeed must be at least 16 bytes for security');
    }
    const array = new Uint8Array(lengthBytes);
    crypto.getRandomValues(array);
    if (encoding === 'hex') {
      return Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
    } else if (encoding === 'base64') {
      return btoa(String.fromCharCode(...array));
    }
    throw new Error('Unsupported encoding');
  }

  async function sha256(input) {
    const encoder = new TextEncoder();
    const data = encoder.encode(input);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
  }

  async function batchGenerateSeeds(total) {
    const batchSize = 5000;
    let processed = 0;
    while (processed < total) {
      const count = Math.min(batchSize, total - processed);
      const batch = [];
      while(batch.length < count) {
        const seed = generateServerSeed(32, 'hex');
        // Make sure to avoid duplicates among existing data and batch
        if (!serverSeedDataArr.find(d => d.serverSeed === seed) && !batch.find(d => d.serverSeed === seed)) {
          batch.push({ serverSeed: seed, serverSeedHashed: await sha256(seed) });
        }
      }
      // Add batch
      for (const item of batch) {
        await addSeed(item);
      }
      processed += count;
      // Allow UI responsive moment
      await new Promise(r => setTimeout(r, 50));
    }
  }

  function applyFilter() {
    const query = searchInput.value.trim().toLowerCase();
    if (query === '') {
      filteredData = serverSeedDataArr.slice();
    } else {
      filteredData = serverSeedDataArr.filter(item =>
        item.serverSeed.toLowerCase().includes(query) ||
        item.serverSeedHashed.toLowerCase().includes(query)
      );
    }
    populateList();
  }

  searchInput.addEventListener('input', () => {
    applyFilter();
  });

  document.addEventListener('click', (event) => {
    if (!serverSeedList.contains(event.target) && event.target !== searchInput) {
      selectItem(-1);
    }
  });

  window.addEventListener('DOMContentLoaded', async () => {
    try {
      await openDb();
      const seeds = await getAllSeeds();
      if (seeds.length === 0) {
        for (const defaultSeed of defaultSeeds) {
          await addSeed(defaultSeed);
        }
      }
      await reloadData();
      if (filteredData.length > 0) selectItem(0);
    } catch (e) {
      alert('Failed to initialize IndexedDB: ' + e.message);
    }
  });
</script>
</body>
</html>
